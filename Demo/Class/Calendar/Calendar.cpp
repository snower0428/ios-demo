#include "Calendar.h"
//#include <jni.h>


// 日历类型，    非法，     儒略，    格利高里
enum CALENDAR_TYPE {CT_INVALID, CT_JULIAN, CT_GREGORIAN,};
// 日月食类型， 无，    日食，   月全食，    月偏食
enum ECLIPSE_TYPE {ET_NONE, ET_SOLAR, ET_MOONFULL, ET_MOONHALF};
// 月相，     无，    朔，    望
enum MOON_PHASE {MP_NONE, MP_SHUO, MP_WANG};

// 自公元前 850 年开始的农历闰月数，-849~2199，移植自中国日历类
int g_leapNumber2[] = 
{
	0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 8, 
	9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 15, 15, 
	15, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21, 
	22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 26, 26, 26, 27, 27, 27, 
	28, 28, 29, 29, 29, 30, 30, 30, 31, 31, 31, 32, 32, 33, 33, 33, 34, 
	34, 34, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 38, 39, 39, 40, 40, 
	40, 41, 41, 41, 42, 42, 43, 43, 43, 44, 44, 44, 45, 45, 46, 46, 46, 
	47, 47, 47, 48, 48, 48, 49, 49, 50, 50, 50, 51, 51, 52, 52, 52, 53, 
	53, 53, 54, 54, 54, 55, 55, 56, 56, 56, 56, 57, 57, 57, 58, 58, 59, 
	59, 59, 59, 60, 60, 61, 61, 62, 62, 63, 63, 64, 64, 64, 64, 65, 65, 
	65, 65, 66, 66, 66, 67, 67, 68, 68, 69, 69, 69, 69, 70, 71, 71, 71, 
	71, 71, 71, 72, 72, 73, 73, 74, 74, 74, 75, 75, 75, 75, 76, 76, 77, 
	77, 77, 77, 78, 79, 79, 79, 79, 79, 80, 80, 80, 81, 82, 82, 82, 83, 
	83, 84, 84, 84, 85, 85, 85, 86, 86, 86, 86, 87, 87, 87, 87, 88, 88, 
	89, 89, 90, 90, 91, 91, 91, 92, 92, 93, 93, 94, 94, 94, 94, 95, 95, 
	96, 96, 96, 96, 97, 97, 98, 98, 98, 99, 99, 100, 100, 100, 101, 101, 
	101, 102, 102, 102, 103, 103, 104, 104, 104, 105, 105, 105, 106, 106, 
	106, 107, 107, 107, 108, 108, 109, 109, 109, 110, 110, 111, 111, 111, 
	112, 112, 112, 113, 113, 114, 114, 114, 115, 115, 116, 116, 116, 117, 
	117, 117, 117, 118, 118, 119, 119, 119, 120, 120, 121, 121, 121, 122, 
	122, 122, 123, 123, 124, 124, 124, 124, 125, 125, 126, 126, 126, 126, 
	127, 127, 128, 128, 129, 129, 130, 130, 130, 130, 131, 131, 132, 132, 
	132, 133, 133, 133, 134, 134, 135, 135, 135, 136, 136, 136, 137, 137, 
	137, 138, 138, 139, 139, 139, 140, 140, 141, 141, 141, 142, 142, 142, 
	143, 143, 143, 144, 144, 144, 145, 145, 146, 146, 146, 147, 147, 147, 
	148, 148, 149, 149, 149, 150, 150, 150, 151, 151, 151, 152, 152, 153, 
	153, 153, 154, 154, 154, 155, 155, 156, 156, 156, 157, 157, 157, 158, 
	158, 158, 159, 159, 160, 160, 160, 161, 161, 161, 162, 162, 163, 163, 
	163, 164, 164, 164, 165, 165, 165, 166, 166, 167, 167, 167, 168, 168, 
	168, 169, 169, 170, 170, 170, 171, 171, 171, 172, 172, 172, 173, 173, 
	174, 174, 174, 175, 175, 175, 176, 176, 177, 177, 177, 178, 178, 178, 
	179, 179, 179, 180, 180, 181, 181, 181, 182, 182, 182, 183, 183, 184, 
	184, 184, 185, 185, 185, 186, 186, 186, 187, 187, 188, 188, 188, 189, 
	189, 189, 190, 190, 191, 191, 191, 192, 192, 192, 193, 193, 193, 194, 
	194, 195, 195, 195, 196, 196, 196, 197, 197, 198, 198, 198, 199, 199, 
	199, 200, 200, 200, 201, 201, 202, 202, 202, 203, 203, 203, 204, 204, 
	205, 205, 205, 206, 206, 206, 207, 207, 207, 208, 208, 209, 209, 209, 
	210, 210, 210, 211, 211, 212, 212, 212, 213, 213, 213, 214, 214, 214, 
	214, 214, 215, 215, 215, 216, 216, 216, 217, 217, 218, 218, 218, 219, 
	219, 219, 220, 220, 221, 221, 221, 222, 222, 222, 223, 223, 223, 224, 
	224, 225, 225, 225, 226, 226, 226, 227, 227, 228, 228, 228, 229, 229, 
	229, 230, 230, 230, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 
	235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 239, 239, 239, 
	240, 240, 240, 241, 241, 242, 242, 242, 243, 243, 243, 244, 244, 244, 
	245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 249, 249, 249, 250, 
	250, 250, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255, 
	255, 256, 256, 256, 257, 257, 257, 258, 258, 259, 259, 259, 260, 260, 
	260, 261, 261, 261, 262, 262, 263, 263, 263, 264, 264, 264, 265, 265, 
	266, 266, 266, 267, 267, 267, 268, 268, 268, 269, 269, 270, 270, 270, 
	271, 271, 271, 272, 272, 273, 273, 273, 274, 274, 274, 275, 275, 276, 
	276, 276, 277, 277, 277, 278, 278, 278, 279, 279, 280, 280, 280, 281, 
	281, 281, 282, 282, 283, 283, 283, 284, 284, 284, 285, 285, 285, 286, 
	286, 287, 287, 287, 288, 288, 288, 289, 289, 290, 290, 290, 291, 291, 
	291, 292, 292, 292, 293, 293, 294, 294, 294, 295, 295, 295, 296, 296, 
	297, 297, 297, 298, 298, 298, 299, 299, 299, 300, 300, 301, 301, 301, 
	302, 302, 302, 303, 303, 304, 304, 304, 305, 305, 305, 306, 306, 306, 
	307, 307, 308, 308, 308, 309, 309, 309, 310, 310, 311, 311, 312, 312, 
	312, 313, 313, 313, 314, 314, 315, 315, 315, 316, 316, 316, 317, 317, 
	317, 318, 318, 319, 319, 319, 320, 320, 320, 321, 321, 322, 322, 322, 
	323, 323, 323, 324, 324, 325, 325, 325, 326, 326, 326, 327, 327, 327, 
	328, 328, 329, 329, 329, 330, 330, 330, 331, 331, 332, 332, 332, 333, 
	333, 333, 334, 334, 334, 335, 335, 336, 336, 336, 337, 337, 337, 338, 
	338, 339, 339, 339, 340, 340, 340, 341, 341, 341, 342, 342, 343, 343, 
	343, 344, 344, 344, 345, 345, 346, 346, 346, 347, 347, 347, 348, 348, 
	348, 349, 349, 350, 350, 350, 351, 351, 351, 352, 352, 353, 353, 353, 
	354, 354, 354, 355, 355, 355, 356, 356, 357, 357, 357, 358, 358, 358, 
	359, 359, 360, 360, 360, 361, 361, 361, 362, 362, 362, 363, 363, 364, 
	364, 364, 365, 365, 365, 366, 366, 367, 367, 367, 368, 368, 368, 369, 
	369, 369, 370, 370, 371, 371, 371, 372, 372, 372, 373, 373, 374, 374, 
	374, 375, 375, 375, 376, 376, 376, 377, 377, 378, 378, 378, 379, 379, 
	379, 380, 380, 381, 381, 381, 382, 382, 382, 383, 383, 383, 384, 384, 
	385, 385, 385, 386, 386, 386, 387, 387, 388, 388, 388, 389, 389, 389, 
	390, 390, 390, 391, 391, 392, 392, 392, 393, 393, 393, 394, 394, 395, 
	395, 395, 396, 396, 396, 397, 397, 397, 398, 398, 399, 399, 399, 400, 
	400, 400, 401, 401, 402, 402, 402, 403, 403, 403, 404, 404, 404, 405, 
	405, 406, 406, 406, 407, 407, 407, 408, 408, 409, 409, 409, 410, 410, 
	410, 411, 411, 411, 412, 412, 413, 413, 413, 414, 414, 414, 415, 415, 
	416, 416, 416, 417, 417, 417, 418, 418, 418, 419, 419, 420, 420, 420, 
	421, 421, 421, 422, 422, 423, 423, 423, 424, 424, 424, 425, 425, 425, 
	426, 426, 427, 427, 427, 428, 428, 428, 429, 429, 430, 430, 430, 431, 
	431, 431, 432, 432, 432, 433, 433, 434, 434, 434, 435, 435, 435, 436, 
	436, 437, 437, 437, 438, 438, 438, 439, 439, 439, 440, 440, 441, 441, 
	441, 442, 442, 442, 443, 443, 444, 444, 444, 445, 445, 445, 446, 446, 
	446, 447, 447, 448, 448, 448, 449, 449, 449, 450, 450, 451, 451, 451, 
	452, 452, 452, 453, 453, 453, 454, 454, 455, 455, 455, 456, 456, 456, 
	457, 457, 458, 458, 458, 459, 459, 459, 460, 460, 460, 461, 461, 462, 
	462, 462, 463, 463, 463, 464, 464, 465, 465, 465, 466, 466, 466, 467, 
	467, 467, 468, 468, 469, 469, 469, 470, 470, 470, 471, 471, 472, 472, 
	472, 473, 473, 473, 474, 474, 474, 475, 475, 475, 476, 476, 477, 477, 
	477, 478, 478, 478, 479, 479, 480, 480, 480, 481, 481, 481, 482, 482, 
	482, 483, 483, 484, 484, 484, 485, 485, 485, 486, 486, 487, 487, 487, 
	488, 488, 488, 489, 489, 489, 490, 490, 491, 491, 491, 492, 492, 492, 
	493, 493, 494, 494, 494, 495, 495, 495, 496, 496, 496, 497, 497, 498, 
	498, 498, 499, 499, 499, 500, 500, 501, 501, 501, 502, 502, 502, 503, 
	503, 503, 504, 504, 505, 505, 505, 506, 506, 506, 507, 507, 508, 508, 
	508, 509, 509, 509, 510, 510, 510, 511, 511, 512, 512, 512, 513, 513, 
	513, 514, 514, 515, 515, 515, 516, 516, 516, 517, 517, 517, 518, 518, 
	519, 519, 519, 520, 520, 520, 521, 521, 522, 522, 522, 523, 523, 523, 
	524, 524, 524, 525, 525, 526, 526, 526, 527, 527, 527, 528, 528, 529, 
	529, 529, 530, 530, 530, 531, 531, 531, 532, 532, 533, 533, 533, 534, 
	534, 534, 535, 535, 536, 536, 536, 537, 537, 537, 538, 538, 538, 539, 
	539, 540, 540, 540, 541, 541, 541, 542, 542, 543, 543, 543, 544, 544, 
	544, 545, 545, 545, 546, 546, 547, 547, 547, 548, 548, 548, 549, 549, 
	550, 550, 550, 551, 551, 551, 552, 552, 552, 553, 553, 554, 554, 554, 
	555, 555, 555, 556, 556, 557, 557, 557, 558, 558, 558, 559, 559, 559, 
	560, 560, 561, 561, 561, 562, 562, 562, 563, 563, 563, 564, 564, 565, 
	565, 565, 566, 566, 566, 567, 567, 568, 568, 568, 569, 569, 569, 570, 
	570, 570, 571, 571, 572, 572, 572, 573, 573, 573, 574, 574, 575, 575, 
	575, 576, 576, 576, 577, 577, 578, 578, 578, 579, 579, 579, 580, 580, 
	580, 581, 581, 582, 582, 582, 583, 583, 583, 584, 584, 584, 585, 585, 
	586, 586, 586, 587, 587, 587, 588, 588, 589, 589, 589, 590, 590, 590, 
	591, 591, 591, 592, 592, 593, 593, 593, 594, 594, 594, 595, 595, 596, 
	596, 596, 597, 597, 597, 598, 598, 598, 599, 599, 600, 600, 600, 601, 
	601, 601, 602, 602, 603, 603, 603, 604, 604, 604, 605, 605, 605, 606, 
	606, 607, 607, 607, 608, 608, 608, 609, 609, 610, 610, 610, 611, 611, 
	611, 612, 612, 612, 613, 613, 614, 614, 614, 615, 615, 615, 616, 616, 
	617, 617, 617, 618, 618, 618, 619, 619, 619, 620, 620, 621, 621, 621, 
	622, 622, 622, 623, 623, 624, 624, 624, 625, 625, 625, 626, 626, 626, 
	627, 627, 628, 628, 628, 629, 629, 629, 630, 630, 631, 631, 631, 632, 
	632, 632, 633, 633, 633, 634, 634, 635, 635, 635, 636, 636, 636, 637, 
	637, 638, 638, 638, 639, 639, 639, 640, 640, 640, 641, 641, 642, 642, 
	642, 643, 643, 643, 644, 644, 645, 645, 645, 646, 646, 646, 647, 647, 
	647, 648, 648, 649, 649, 649, 650, 650, 650, 651, 651, 652, 652, 652, 
	653, 653, 653, 654, 654, 654, 655, 655, 656, 656, 656, 657, 657, 657, 
	658, 658, 659, 659, 659, 660, 660, 660, 661, 661, 661, 662, 662, 663, 
	663, 663, 664, 664, 664, 665, 665, 666, 666, 666, 667, 667, 667, 668, 
	668, 668, 669, 669, 670, 670, 670, 671, 671, 671, 672, 672, 673, 673, 
	673, 674, 674, 674, 675, 675, 675, 676, 676, 677, 677, 677, 678, 678, 
	678, 679, 679, 680, 680, 680, 681, 681, 681, 682, 682, 682, 683, 683, 
	684, 684, 684, 685, 685, 685, 686, 686, 687, 687, 687, 688, 688, 688, 
	689, 689, 689, 690, 690, 691, 691, 691, 692, 692, 692, 693, 693, 694, 
	694, 694, 695, 695, 695, 696, 696, 696, 697, 697, 698, 698, 698, 699, 
	699, 699, 700, 700, 701, 701, 701, 702, 702, 702, 703, 703, 703, 704, 
	704, 705, 705, 705, 706, 706, 706, 707, 707, 707, 708, 708, 709, 709, 
	709, 710, 710, 710, 711, 711, 712, 712, 712, 713, 713, 713, 714, 714, 
	714, 715, 715, 716, 716, 716, 717, 717, 717, 718, 718, 719, 719, 719, 
	720, 720, 720, 721, 721, 721, 722, 722, 723, 723, 723, 724, 724, 724, 
	725, 725, 726, 726, 726, 727, 727, 727, 728, 728, 728, 729, 729, 730, 
	730, 730, 731, 731, 731, 732, 732, 733, 733, 733, 734, 734, 734, 735, 
	735, 736, 736, 736, 737, 737, 737, 738, 738, 738, 739, 739, 740, 740, 
	740, 741, 741, 741, 742, 742, 742, 743, 743, 744, 744, 744, 745, 745, 
	745, 746, 746, 747, 747, 747, 748, 748, 748, 749, 749, 749, 750, 750, 
	751, 751, 751, 752, 752, 752, 754, 754, 755, 755, 755, 756, 756, 756, 
	757, 757, 757, 758, 758, 759, 759, 759, 760, 760, 760, 761, 761, 762, 
	762, 762, 763, 763, 763, 764, 764, 764, 765, 765, 766, 766, 766, 767, 
	767, 767, 768, 768, 769, 769, 769, 770, 770, 770, 771, 771, 771, 772, 
	772, 773, 773, 773, 774, 774, 774, 775, 775, 776, 776, 776, 777, 777, 
	777, 778, 778, 778, 779, 779, 780, 780, 780, 781, 781, 781, 782, 782, 
	783, 783, 783, 784, 784, 784, 785, 785, 785, 786, 786, 787, 787, 787, 
	788, 788, 788, 789, 789, 790, 790, 790, 791, 791, 791, 792, 792, 792, 
	793, 793, 794, 794, 794, 795, 795, 795, 796, 796, 796, 797, 797, 798, 
	798, 798, 799, 799, 799, 800, 800, 801, 801, 801, 802, 802, 802, 803, 
	803, 804, 804, 804, 805, 805, 805, 806, 806, 806, 807, 807, 808, 808, 
	808, 809, 809, 809, 810, 810, 810, 811, 811, 812, 812, 812, 813, 813, 
	813, 814, 814, 815, 815, 815, 816, 816, 816, 817, 817, 818, 818, 818, 
	819, 819, 819, 820, 820, 820, 821, 821, 822, 822, 822, 823, 823, 823, 
	824, 824, 825, 825, 825, 826, 826, 826, 827, 827, 827, 828, 828, 829, 
	829, 829, 830, 830, 830, 831, 831, 832, 832, 832, 833, 833, 833, 834, 
	834, 834, 835, 835, 836, 836, 836, 837, 837, 837, 838, 838, 839, 839, 
	839, 840, 840, 840, 841, 841, 841, 842, 842, 843, 843, 843, 844, 844, 
	844, 845, 845, 845, 846, 846, 847, 847, 847, 848, 848, 848, 849, 849, 
	850, 850, 850, 851, 851, 851, 852, 852, 852, 853, 853, 854, 854, 854, 
	855, 855, 855, 856, 856, 857, 857, 857, 858, 858, 858, 859, 859, 859, 
	860, 860, 861, 861, 861, 862, 862, 862, 863, 863, 864, 864, 863, 864, 
	864, 864, 865, 865, 865, 866, 866, 867, 867, 867, 868, 868, 868, 869, 
	869, 870, 870, 870, 871, 871, 871, 872, 872, 873, 873, 873, 874, 874, 
	874, 875, 875, 875, 876, 876, 877, 877, 877, 878, 878, 878, 879, 879, 
	879, 880, 880, 881, 881, 881, 882, 882, 882, 883, 883, 884, 884, 884, 
	885, 885, 885, 886, 886, 886, 887, 887, 888, 888, 888, 889, 889, 889, 
	890, 890, 891, 891, 891, 892, 892, 892, 893, 893, 893, 894, 894, 895, 
	895, 895, 896, 896, 896, 897, 897, 898, 898, 898, 899, 899, 899, 900, 
	900, 900, 901, 901, 902, 902, 902, 903, 903, 903, 904, 904, 905, 905, 
	905, 906, 906, 906, 907, 907, 907, 908, 908, 909, 909, 909, 910, 910, 
	910, 911, 911, 912, 912, 912, 913, 913, 913, 914, 914, 914, 915, 915, 
	916, 916, 916, 917, 917, 917, 918, 918, 919, 919, 919, 920, 920, 920, 
	921, 921, 921, 922, 922, 923, 923, 923, 924, 924, 924, 925, 925, 925, 
	926, 926, 927, 927, 927, 928, 928, 928, 929, 929, 930, 930, 930, 931, 
	931, 931, 932, 932, 932, 933, 933, 934, 934, 934, 935, 935, 935, 936, 
	936, 937, 937, 937, 938, 938, 938, 939, 939, 939, 940, 940, 941, 941, 
	941, 942, 942, 942, 943, 943, 944, 944, 944, 945, 945, 945, 946, 946, 
	946, 947, 947, 948, 948, 948, 949, 949, 949, 950, 950, 951, 951, 951, 
	952, 952, 952, 953, 953, 953, 954, 954, 955, 955, 955, 956, 956, 956, 
	957, 957, 958, 958, 958, 959, 959, 959, 960, 960, 960, 961, 961, 962, 
	962, 962, 963, 963, 963, 964, 964, 965, 965, 965, 966, 966, 966, 967, 
	967, 967, 968, 968, 969, 969, 969, 970, 970, 970, 971, 971, 971, 972, 
	972, 973, 973, 973, 974, 974, 974, 975, 975, 976, 976, 976, 977, 977, 
	977, 978, 978, 978, 979, 979, 980, 980, 980, 981, 981, 981, 982, 982, 
	983, 983, 983, 984, 984, 984, 985, 985, 986, 986, 986, 987, 987, 987, 
	988, 988, 988, 989, 989, 990, 990, 990, 991, 991, 991, 992, 992, 993, 
	993, 993, 994, 994, 994, 995, 995, 995, 996, 996, 997, 997, 997, 998, 
	998, 998, 999, 999, 1000, 1000, 1000, 1001, 1001, 1001, 1002, 1002, 
	1002, 1003, 1003, 1004, 1004, 1004, 1005, 1005, 1005, 1006, 1006, 
	1006, 1007, 1007, 1008, 1008, 1008, 1009, 1009, 1009, 1010, 1010, 
	1011, 1011, 1011, 1012, 1012, 1012, 1013, 1013, 1013, 1014, 1014, 
	1015, 1015, 1015, 1016, 1016, 1016, 1017, 1017, 1018, 1018, 1018, 
	1019, 1019, 1019, 1020, 1020, 1020, 1021, 1021, 1022, 1022, 1022, 
	1023, 1023, 1023, 1024, 1024, 1025, 1025, 1025, 1026, 1026, 1026, 
	1027, 1027, 1027, 1028, 1028, 1029, 1029, 1029, 1030, 1030, 1030, 
	1031, 1031, 1032, 1032, 1032, 1033, 1033, 1033, 1034, 1034, 1034, 
	1035, 1035, 1036, 1036, 1036, 1037, 1037, 1037, 1038, 1038, 1039, 
	1039, 1039, 1040, 1040, 1040, 1041, 1041, 1042, 1042, 1042, 1043, 
	1043, 1043, 1044, 1044, 1044, 1045, 1045, 1046, 1046, 1046, 1047, 
	1047, 1047, 1048, 1048, 1048, 1049, 1049, 1050, 1050, 1050, 1051, 
	1051, 1051, 1052, 1052, 1053, 1053, 1053, 1054, 1054, 1054, 1055, 
	1055, 1055, 1056, 1056, 1057, 1057, 1057, 1058, 1058, 1058, 1059, 
	1059, 1060, 1060, 1060, 1061, 1061, 1061, 1062, 1062, 1062, 1063, 
	1063, 1064, 1064, 1064, 1065, 1065, 1065, 1066, 1066, 1067, 1067, 
	1067, 1068, 1068, 1068, 1069, 1069, 1069, 1070, 1070, 1071, 1071, 
	1071, 1072, 1072, 1072, 1073, 1073, 1074, 1074, 1074, 1075, 1075, 
	1075, 1076, 1076, 1076, 1077, 1077, 1078, 1078, 1078, 1079, 1079, 
	1079, 1080, 1080, 1081, 1081, 1081, 1082, 1082, 1082, 1083, 1083, 
	1083, 1084, 1084, 1085, 1085, 1085, 1086, 1086, 1086, 1087, 1087, 
	1088, 1088, 1088, 1089, 1089, 1089, 1090, 1090, 1090, 1091, 1091, 
	1092, 1092, 1092, 1093, 1093, 1093, 1094, 1094, 1095, 1095, 1095, 
	1096, 1096, 1096, 1097, 1097, 1097, 1098, 1098, 1099, 1099, 1099, 
	1100, 1100, 1100, 1101, 1101, 1102, 1102, 1102, 1103, 1103, 1103, 
	1104, 1104, 1104, 1105, 1105, 1106, 1106, 1106, 1107, 1107, 1107, 
	1108, 1108, 1109, 1109, 1109, 1110, 1110, 1110, 1111, 1111, 1111, 
	1112, 1112, 1113, 1113, 1113, 1114, 1114, 1114, 1115, 1115, 1116, 
	1116, 1116, 1117, 1117, 1117, 1118, 1118, 1118, 1119, 1119, 1120, 
	1120, 1120, 1121
};

// 自公元前 850 年开始的农历闰月信息 -849~2199，移植自中国日历类
char g_leapMonth2[] =
{
	"0c0080050010a0070030c0080050010a0070030c0080050020a0070030c0080050020a"
	"0070030c0090050020a0070030c0090050020a0060030c0060030c00900600c0c0060c"
	"00c00c00c0c000600c0c0006090303030006000c00c060c0006c00000c0c0c00600030"
	"30006c00009009c0090c00c009000300030906030030c0c00060c00090c0060600c003"
	"0060c00c003006009060030c0060060c0090900c00090c0090c00c0060300060600030"
	"30c0c00030c0060030c0090060030c0090300c0080050020a0060030c0080050020b00"
	"70030c0090050010a0070030b0090060020a0070040c0080050020a0060030c0080050"
	"020b0070030c0090050010a0070030b0090060020a0070040c0080050020a0060030c0"
	"080050020b0070030c0090050000c00900909009009090090090090900900909009009"
	"0090900900909009009009090090090900900900909009009090090090900900900909"
	"00900909009009009090090090900900900909009009090060030c0090050010a00700"
	"30b008005001090070040c0080050020a0060030c0090040010a0060030c0090050010"
	"a0070030b0080050010a008005001090050020a0060030c0080040010a0060030c0090"
	"050010a0070030b0080050010a0070030b008005001090070040c0080050020a006003"
	"0c0080040010a0060030c0090050010a0070030b008005001090070040c0080050020a"
	"0060030c0080040010a0060030c0090050010a0060030c0090050010a0070030b00800"
	"5001090070040c0080050020a0060030c0080040010a0070030b0080050010a0070040"
	"c0080050020a0060030c0080040010a0070030c0090050010a0070030b0080050020a0"
	"060030c0080040010a0060030c0090050050020a0060030c0090050010b0070030c009"
	"0050010a0070040c0080040020a0060030c0080050020a0060030c0090050010a00700"
	"30b0080040020a0060040c0090050020b0070030c00a0050010a0070030b0090050020"
	"a0070030c0080040020a0060030c0090050010a0070030c0090050030b007005001090"
	"050020a007004001090060020c0070050c0090060030b0080040020a0060030b008004"
	"0010a0060030b0080050010a0050040c0080050010a0060030c0080050010b0070030c"
	"007005001090070030b0070040020a0060030c0080040020a0070030b0090050010a00"
	"60040c0080050020a0060040c0080050010b0070030c007005001090070030c0080050"
	"020a0070030c0090050020a0070030c0090050020a0060040c0090050020a0060040c0"
	"090050010b0070030c0080050030b007004001090060020c008004002090060020a008"
	"004001090050030b0080040020a0060040b0080040c00a0060020b0070050010900600"
	"30b0070050020a0060020c008004002090070030c008005002090070040c0080040020"
	"a0060040b0090050010a0060030b0080050020a0060040c0080050010b007003001080"
	"05001090070030c0080050020a007003001090050030a0070030b0090050020a006004"
	"0c0090050030b0070040c0090050010c0070040c0080060020b00700400a090060020b"
	"007003002090060020a005004001090050030b007004001090050040c0080040c00a00"
	"60020c007005001090060030b0070050020a0060020c008004002090060030b0080040"
	"02090060030b0080040020a0060040b0080040010b0060030b0070050010a006004002"
	"0700500308006004003070050030700600400307005003080060040030700500409006"
	"0040030700500409006005002070050030a00600500307005004002060040020600500"
	"30020600400307005004090060040030700500408007005003080050040a0060050030"
	"7005004002060050030800500400206005002070050040020600500307006004002070"
	"050030800600400307005004080060040a006005003080050040020700500409006004"
	"002060050030b006005002070050030800600400307005004080060040030700500408"
	"00600400207005004090060040030700500409006005002070050040b0060050030700"
	"60040a006005003070060040800600500307006"
};

std::string g_ganZhi2[] =
{"甲子", "乙丑", "丙寅", "丁卯", "戊辰", "己巳", "庚午", "辛未", "壬申", "癸酉",
"甲戌", "乙亥", "丙子", "丁丑", "戊寅", "己卯", "庚辰", "辛巳", "壬午", "癸未",
"甲申", "乙酉", "丙戌", "丁亥", "戊子", "己丑", "庚寅", "辛卯", "壬辰", "癸巳",
"甲午", "乙未", "丙申", "丁酉", "戊戌", "己亥", "庚子", "辛丑", "壬寅", "癸卯",
"甲辰", "乙巳", "丙午", "丁未", "戊申", "己酉", "庚戌", "辛亥", "壬子", "癸丑",
"甲寅", "乙卯", "丙辰", "丁巳", "戊午", "己未", "庚申", "辛酉", "壬戌", "癸亥"};

int Calendar::lunarInfo[]={
 0x04bd8,0x04ae0,0x0a570,0x054d5,0x0d260,0x0d950,0x16554,0x056a0,0x09ad0,0x055d2,
 0x04ae0,0x0a5b6,0x0a4d0,0x0d250,0x1d255,0x0b540,0x0d6a0,0x0ada2,0x095b0,0x14977,
 0x04970,0x0a4b0,0x0b4b5,0x06a50,0x06d40,0x1ab54,0x02b60,0x09570,0x052f2,0x04970,
 0x06566,0x0d4a0,0x0ea50,0x06e95,0x05ad0,0x02b60,0x186e3,0x092e0,0x1c8d7,0x0c950,
 0x0d4a0,0x1d8a6,0x0b550,0x056a0,0x1a5b4,0x025d0,0x092d0,0x0d2b2,0x0a950,0x0b557,
 0x06ca0,0x0b550,0x15355,0x04da0,0x0a5d0,0x14573,0x052d0,0x0a9a8,0x0e950,0x06aa0,
 0x0aea6,0x0ab50,0x04b60,0x0aae4,0x0a570,0x05260,0x0f263,0x0d950,0x05b57,0x056a0,
 0x096d0,0x04dd5,0x04ad0,0x0a4d0,0x0d4d4,0x0d250,0x0d558,0x0b540,0x0b5a0,0x195a6,
 0x095b0,0x049b0,0x0a974,0x0a4b0,0x0b27a,0x06a50,0x06d40,0x0af46,0x0ab60,0x09570,
 0x04af5,0x04970,0x064b0,0x074a3,0x0ea50,0x06b58,0x055c0,0x0ab60,0x096d5,0x092e0,
 0x0c960,0x0d954,0x0d4a0,0x0da50,0x07552,0x056a0,0x0abb7,0x025d0,0x092d0,0x0cab5,
 0x0a950,0x0b4a0,0x0baa4,0x0ad50,0x055d9,0x04ba0,0x0a5b0,0x15176,0x052b0,0x0a930,
 0x07954,0x06aa0,0x0ad50,0x05b52,0x04b60,0x0a6e6,0x0a4e0,0x0d260,0x0ea65,0x0d530,
 0x05aa0,0x076a3,0x096d0,0x04bd7,0x04ad0,0x0a4d0,0x1d0b6,0x0d250,0x0d520,0x0dd45,
 0x0b5a0,0x056d0,0x055b2,0x049b0,0x0a577,0x0a4b0,0x0aa50,0x1b255,0x06d20,0x0ada0
};
int Calendar::solarMonth[]={31,28,31,30,31,30,31,31,30,31,30,31};

// 农历每年的距离农历1900年1月1日天数之和（1900~2049）(农历1900年为384天)
int Calendar::NlYearDaysList[] = {
	384,  738,  1093, 1476, 1830, 2185, 2569, 2923, 3278, 3662,
	4016, 4400, 4754, 5108, 5492, 5846, 6201, 6585, 6940, 7324,
	7678, 8032, 8416, 8770, 9124, 9509, 9863, 10218,10602,10956,
	11339,11693,12048,12432,12787,13141,13525,13879,14263,14617,
	14971,15355,15710,16064,16449,16803,17157,17541,17895,18279,
	18633,18988,19372,19726,20081,20465,20819,21202,21557,21911,
	22295,22650,23004,23388,23743,24096,24480,24835,25219,25573,
	25928,26312,26666,27020,27404,27758,28142,28496,28851,29235,
	29590,29944,30328,30682,31066,31420,31774,32158,32513,32868,
	33252,33606,33960,34343,34698,35082,35436,35791,36175,36529,
	36883,37267,37621,37976,38360,38714,39099,39453,39807,40191,
	40545,40899,41283,41638,42022,42376,42731,43115,43469,43823,
	44207,44561,44916,45300,45654,46038,46392,46746,47130,47485,
	47839,48223,48578,48962,49316,49670,50054,50408,50762,51146,
	51501,51856,52240,52594,52978,53332,53686,54070,54424,54479
};

// 公历每年距离公历1900年1月1日天数之和
int Calendar::GlYearDaysList[] = {
	365,  730,  1095, 1460, 1826, 2191, 2556, 2921, 3287, 3652,
	4017, 4382, 4748, 5113, 5478, 5843, 6209, 6574, 6939, 7304,
	7670, 8035, 8400, 8765, 9131, 9496, 9861, 10226,10592,10957,
	11322,11687,12053,12418,12783,13148,13514,13879,14244,14609,
	14975,15340,15705,16070,16436,16801,17166,17531,17897,18262,
	18627,18992,19358,19723,20088,20453,20819,21184,21549,21914,
	22280,22645,23010,23375,23741,24106,24471,24836,25202,25567,
	25932,26297,26663,27028,27393,27758,28124,28489,28854,29219,
	29585,29950,30315,30680,31046,31411,31776,32141,32507,32872,
	33237,33602,33968,34333,34698,35063,35429,35794,36159,36524,
	36890,37255,37620,37985,38351,38716,39081,39446,39812,40177,
	40542,40907,41273,41638,42003,42368,42734,43099,43464,43829,
	44195,44560,44925,45290,45656,46021,46386,46751,47117,47482,
	47847,48212,48578,48943,49308,49673,50039,50404,50769,51134,
	51500,51865,52230,52595,52961,53326,53691,54056,54422,54787
};


//==============================================================================================
// 函 数 名：LYearDays
// 功能描述：指定农历年的总天数
// 输入参数：y  指定农历年
// 输出参数：int 指定农历年的总天数
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
int Calendar::LYearDays(int y)
{
	int i = 348;
	int sum = 348; 
	for(i=0x8000; i>0x8; i>>=1)
	{
		sum += (lunarInfo[y-1900] & i)? 1: 0;
	}
	
	if (lunarInfo[y-1900]&0xf)
	{
		return sum + ((lunarInfo[y-1900] & 0x10000)? 30: 29);
	}
	else
	{
		return sum;
	}

	//return(sum+LeapDays(y));
}

//==============================================================================================
// 函 数 名：LeapDays
// 功能描述：传回指定农历年闰月的天数
// 输入参数：y  指定农历年
// 输出参数：int 指定农历年闰月的天数
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
int Calendar::LeapDays(int y)
{
	return LeapDaysFun(y);
	//if(LeapMonth(y));
	//{
	//	return (lunarInfo[y-1900] & 0x10000)? 30: 29;
	//}
	//else
	//{
	//	return 0;
	//}
}
//==============================================================================================
// 函 数 名：LeapMonth
// 功能描述：传回指定农历年的闰月
// 输入参数：y  指定农历年
// 输出参数：int 指定农历年的闰月
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
int Calendar::LeapMonth(int y)
{
	return GetLeapMonth(y);
   //return lunarInfo[y-1900] & 0xf;
}
//==============================================================================================
// 函 数 名：MonthDays
// 功能描述：传回农历 y年m月的总天数
// 输入参数：y  指定农历年
//           m  指定农历月
// 输出参数：int 农历 y年m月的总天数
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
int Calendar::MonthDays(int y,int m)
{
	return MonthDaysFun(y, m);
	//return (lunarInfo[y-1900] & (0x10000>>m))? 30: 29;
}

//==============================================================================================
// 函 数 名：LDaysFrom1900
// 功能描述：传回date与1900年相差的天数
// 输入参数：date  指定日期
// 输出参数：int   date与1900年相差的天数
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
long Calendar::LDaysFrom1900(const DateInfo&  date)
{
	long days;

	days=365*date.year+(date.year-1)/4-(date.year-1)/100+(date.year-1)/400-
	(365*1900+(1900-1)/4-(1900-1)/100+(1900-1)/400);

	for(int i=0;i<date.month-1;i++)
	{
		days+=solarMonth[i];
	}
	days+=date.day;
	if((date.year%4==0&&date.year%100!=0)||date.year%400==0)
	{
		if(date.month>2)
		{
			days++;
		}
	}
	return days;
}
//==============================================================================================
// 函 数 名：Lunar
// 功能描述：输入阴历日期,返回阴历日期
// 输入参数：date       指定阴历日期
// 输出参数：DateInfo   阴历日期
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
DateInfo Calendar::Lunar(const DateInfo&  date)
{
	DateInfo retdate;
	//用新代码
	if (date.year < 1901 || date.year > 2049)
	{
		retdate.year = date.year;
		retdate.month = date.month;
		retdate.day = date.day;
		retdate.isRunYue = false;
		GetLunarFromDay(date.year, date.month, date.day, retdate.year, retdate.month, retdate.day, retdate.isRunYue);
	}
	else
	{
		retdate = Calendar::LunarEx(date);
	}

	return retdate;
}

//==============================================================================================
// 函 数 名：IsLeapYear
// 功能描述：判断指定年是否闰年
// 输入参数：year       指定年
// 输出参数：bool       是否闰年
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
bool Calendar::IsLeapYear(int year)
{
	return (year%4==0&&year%100!=0)||(year%400==0);
}

//==============================================================================================
// 函 数 名：GetLunarInfo
// 功能描述：输入阴历日期,得到表示农历的信息
// 输入参数：date       指定阴历日期
// 输出参数：LunarInfo  农历的信息
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
//LunarInfo Calendar::GetLunarInfo (const DateInfo&  date)
//{
//	//考虑到某年的立春在正月中，如果这个日期处于正月初一和立春（不含立春）之间，那么年的干支要向上推一个
//	//剩下的月份，日之类的计算不变。转成公历也是为了能够调用GetGanZhiFromYear。
//	DateInfo l_glDate;
//	DateInfo l_CalDate;//修正过的农历日期，与date相比只可能在year上有不同
//	int NLYear = 0;
//	l_glDate = GetGlDate(date);
//	GetGanZhiFromYear(l_glDate.year, l_glDate.month, l_glDate.day, 0, NLYear);
//	l_CalDate.year = NLYear;
//	l_CalDate.month = date.month;
//	l_CalDate.day = date.day;
//	l_CalDate.isRunYue = date.isRunYue;
//
//	LunarInfo l_lunarinfo;
//	const char *cTianGan[]  = {"甲","乙","丙","丁","戊","己","庚","辛","壬","癸"}; /*天干名称*/
//	const char *cDiZhi[]    = {"子","丑","寅","卯","辰","巳","午", "未","申","酉","戌","亥"}; /*地支名称*/
//	const char *cShuXiang[] = {"鼠","牛","虎","兔","龙","蛇","马","羊","猴","鸡","狗","猪"}; /*属相名称*/
//	const char *cDayName[]  = { "*","初一","初二","初三","初四","初五", /*农历日期名*/
//		"初六","初七","初八","初九","初十",
//		"十一","十二","十三","十四","十五",
//		"十六","十七","十八","十九","二十",
//		"廿一","廿二","廿三","廿四","廿五",
//		"廿六","廿七","廿八","廿九","三十"};
//	const char *cMonName[]  = {"*","正","二","三","四","五","六", "七","八","九","十","十一","腊"};
//
//	/*--生成农历天干、地支、属相 ==> wNongli--*/
//	int nShuXiang = ((l_CalDate.year - 4) % 60) % 12;
//	if ( nShuXiang < 0 || nShuXiang >= (int)(sizeof(cShuXiang)/sizeof(cShuXiang[0])) )
//	{
//		LunarInfo l_lunarinfo_error;
//		return l_lunarinfo_error ;
//	}
//	l_lunarinfo.shenxiao = cShuXiang[nShuXiang];
//	int nTianGan = ((l_CalDate.year - 4) % 60) % 10;
//	if ( nTianGan < 0 || nTianGan >= (int)(sizeof(cTianGan)/sizeof(cTianGan[0])) )
//	{
//		 LunarInfo l_lunarinfo_error;
//		 return l_lunarinfo_error ;
//	}
//	l_lunarinfo.tiangan = cTianGan[nTianGan];
//	int nDiZhi = ((l_CalDate.year - 4) % 60) % 12;
//	if ( nDiZhi < 0 || nDiZhi >= (int)(sizeof(cDiZhi)/sizeof(cDiZhi[0])) )
//	{
//		 LunarInfo l_lunarinfo_error;
//		 return l_lunarinfo_error ;
//	}
//	l_lunarinfo.dizhi = cDiZhi[nDiZhi];
//
//
//	/*--生成农历月、日 ==> wNongliDay--*/
//	if ( l_CalDate.month < 0 || l_CalDate.month >= (int)(sizeof(cMonName)/sizeof(cMonName[0])) )
//	{
//		 LunarInfo l_lunarinfo_error;
//		 return l_lunarinfo_error ;
//	}
//	l_lunarinfo.isLeepMonth = l_CalDate.isRunYue;
//	l_lunarinfo.monthname = cMonName[l_CalDate.month];
//
//	if ( l_CalDate.day < 0 || l_CalDate.day >= (int)(sizeof(cDayName)/sizeof(cDayName[0])) )
//	{
//		 LunarInfo l_lunarinfo_error;
//		 return l_lunarinfo_error ;
//	}
//	l_lunarinfo.dayname = cDayName[l_CalDate.day];
//	return l_lunarinfo;
//}

// 输入阳历日期,得到表示农历的信息
//LunarInfo Calendar::GetLunarInfoByYanLi (const DateInfo&  date )
//{
//	return GetLunarInfo(Lunar(date));
//}


//==============================================================================================
// 函 数 名：DayOfWeek
// 功能描述：输入阳历日期，返回星期几
// 输入参数：date       指定阳历日期
// 输出参数：char*      具体的信息
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
const char* Calendar::DayOfWeek(DateInfo  date)
{
	const char *cWeekName[]  = {"星期日","星期一","星期二","星期三","星期四","星期五","星期六"};

	if(date.month==1||date.month==2)
	{
		date.month+=12;
		date.year--;
	}
	return cWeekName[(date.day+1+2*date.month+3*(date.month+1)/5+date.year+date.year/4-date.year/100+date.year/400)%7];
}

// 输入阳历日期，返回星期几
const char* Calendar::DayOfWeekZhou(DateInfo  date)
{
	const char *cWeekName[]  = {"日","一","二","三","四","五","六"};

	if(date.month==1||date.month==2)
	{
		date.month+=12;
		date.year--;
	}
	return cWeekName[(date.day+1 + 2*date.month + 3*(date.month+1)/5 + date.year + date.year/4 - date.year/100 + date.year/400) % 7];
}


/************************************************************************************
 * @brief//输入阳历日期，返回星期几
 * 
 * 
 * @n<b>函数名称</b>      : DayOfWeekFlag
 * @n@param DateInfo date :
 * @return                 
 * @see                    
 * @n<b>作者</b>          :邱堃
 * @n<b>创建时间</b>      : 2010-7-20 13:43:55
 * @version	修改者        时间        描述@n
 * @n		邱堃          2010-07-20
 ************************************************************************************/
int Calendar::DayOfWeekFlag(DateInfo  date)
{
	if(date.month==1||date.month==2)
	{
		date.month+=12;
		date.year--;
	}
	int iTemp = (date.day+1+2*date.month+3*(date.month+1)/5+date.year+date.year/4-date.year/100+date.year/400)%7;
	return iTemp;
}

//==============================================================================================
// 函 数 名：SolarDays
// 功能描述：传回公历 y年m+1月的天数
// 输入参数：y          指定年
//           m          指定月
// 输出参数：int        y年m+1月的天数
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
int Calendar::SolarDays(int y,int m)
{
	if ( m > 11 || m< 0)
	{
		return 0;
	}
	if(m==1)//2月
	{
		return((((y%4 == 0) && (y%100 != 0)) || (y%400 == 0))? 29: 28);
	}
	else
	{
		return(solarMonth[m]);
	}
}

//==============================================================================================
// 函 数 名：GetLunarTime
// 功能描述：获取某个时间的时辰
// 输入参数：hour       指定时间
// 输出参数：string     时辰
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
std::string Calendar::GetLunarTime(int hour)
{
	const char *cLunarTime[]    = {"子","丑","寅","卯","辰","巳","午", "未","申","酉","戌","亥"};

	int l_timeindex;

	switch (hour)
	{
	case 1:
	case 2:
		l_timeindex = 1;
		break;
	case 3:
	case 4:
		l_timeindex = 2;
		break;
	case 5:
	case 6:
		l_timeindex = 3;
		break;	      
	case 7:
	case 8:
		l_timeindex = 4;
		break;	
	case 9:
	case 10:
		l_timeindex = 5;
		break;	
	case 11:
	case 12:
		l_timeindex = 6;
		break;	
	case 13:
	case 14:
		l_timeindex = 7;
		break;
	case 15:
	case 16:
		l_timeindex = 8;
		break;
	case 17:
	case 18:
		l_timeindex = 9;
		break;
	case 19:
	case 20:
		l_timeindex = 10;
		break;
	case 21:
	case 22:
		l_timeindex = 11;
		break;
	case 23:
	case 0:
		l_timeindex = 0;
		break;
	default:
		l_timeindex = 0;
	}

	return std::string(cLunarTime[l_timeindex]);

}

//==============================================================================================
// 函 数 名：GetLlGZDay
// 功能描述：获取农历干支日
// 输入参数：date       公历日期
// 输出参数：string     农历日干支
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
std::string Calendar::GetLlGZDay(DateInfo  date)
{
	int l_index = GetGanZhiFromDay(date.year, date.month, date.day, date.hour);
	if (l_index>=0 && l_index<60)
	{
		return g_ganZhi2[l_index];
	}

	// 1月和2月按上一年的13月和14月来算;
	if( date.month == 1 )
	{
		date.year -= 1;
		date.month = 13;
	}
	if( date.month == 2 )
	{
		date.year -= 1;
		date.month = 14;
	}
	std::string l_s_tiangan[] = {"甲","乙","丙","丁","戊","己","庚","辛","壬","癸"};/*天干名称*/
	std::string l_s_dizhi[] =  {"子","丑","寅","卯","辰","巳","午", "未","申","酉","戌","亥"};

	int l_i_c = 0;
	if(date.year>100) l_i_c = date.year / 100;
	int l_i_y = date.year%100;

	int l_i_i = (date.month % 2 ==0)? 6 : 0;
  
    int l_i_g = ((4* l_i_c + (int)(l_i_c / 4) + 5 * l_i_y + (int)(l_i_y / 4) + (int)(3* (date.month +1) / 5) + date.day -3)) % 10;
	if(l_i_g==0) l_i_g = 10;
    int l_i_z = ((8* l_i_c + (int)(l_i_c / 4)+ 5 * l_i_y  + (int)(l_i_y / 4) + (int)(3* (date.month +1) / 5) + date.day + 7 + l_i_i )) % 12;
	if(l_i_z==0) l_i_z = 12;
	return l_s_tiangan[l_i_g-1]+l_s_dizhi[l_i_z-1];

}

//==============================================================================================
// 函 数 名：GetLlGZMonth
// 功能描述：获取农历干支月【注意：此处获取的是具体某天所在月的月干支】
// 输入参数：date       农历日期
// 输出参数：string     农历月干支
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
//std::string Calendar::GetLlGZMonth(const DateInfo&  date)
//{
//	DateInfo l_glDate;
//	int l_index = 0;
//	l_glDate = GetGlDate(date);
//	l_index = GetGanZhiFromMonth(l_glDate.year, l_glDate.month, l_glDate.day, 0);
//	return g_ganZhi2[l_index];
//
//	std::string datasets[5][12] = { {"丙寅","丁卯","戊辰","己巳","庚午","辛未","壬申","癸酉","甲戌","乙亥","丙子","丁丑"},
//									{"戊寅","己卯","庚辰","辛巳","壬午","癸未","甲申","乙酉","丙戌","丁亥","戊子","己丑"},
//									{"庚寅","辛卯","壬辰","癸巳","甲午","乙未","丙申","丁酉","戊戌","己亥","庚子","辛丑"},
//									{"壬寅","癸卯","甲辰","乙巳","丙午","丁未","戊申","己酉","庚戌","辛亥","壬子","癸丑"},
//									{"甲寅","乙卯","丙辰","丁巳","戊午","己未","庚申","辛酉","壬戌","癸亥","甲子","乙丑"}};
//
//    LunarInfo l_nlinfo = GetLunarInfo(date);
//
//	std::string TianG[]  = {"甲","乙","丙","丁","戊","己","庚","辛","壬","癸"}; /*天干名称*/
//
//	int l_i_y=0;
//	for(int i=0;i<10;++i)
//	{
//		if(l_nlinfo.tiangan==TianG[i])
//		{
//			l_i_y = i;
//			break;
//		}
//	}
//
//	l_i_y %= 5;
//
//	int l_i_m = 0;
//
//	std::string MonName[]  = {"*","正","二","三","四","五","六", "七","八","九","十","十一","腊"};
//	for(int i=0;i<13;++i)
//	{
//		
//		if(l_nlinfo.monthname==MonName[i])
//		{
//			l_i_m = i;
//			break;
//		}
//	}
//
//	if(l_i_m > 0) l_i_m -= 1;
//
//	return datasets[l_i_y][l_i_m];
//}

//==============================================================================================
// 函 数 名：GetLlGZMonth_GanZhi
// 功能描述：获取农历干支月【注意：此处获取的是某个农历月总的月干支】
// 输入参数：date       农历日期
// 输出参数：string     农历月干支
// 创建日期：2008-09-19
// 作 者：檀杨挺
//==============================================================================================
std::string Calendar::GetLlGZMonth_GanZhi(const DateInfo&  date)
{
	/*****
	正月为寅月，立春一般为每年2月4日或者5日，立春那天月支变为寅，只要求出立春天月干，得出正月干支，
	余下十一月的干支则通过六十甲子干支循环表查询。
	*****/

	DateInfo l_glDate;
	int l_index = 0;
	l_glDate = GetGlDate(date);

	// 求出该农历年正月的干支(就是求立春过后的干支，每年的公立2月7日一般就是过了立春了，属于正月范围)
	// 得出正月所所在的索引（索引针对的表是：g_ganZhi2，丙寅2，戊寅14，庚寅26，壬寅38，甲寅50）
	l_index = GetGanZhiFromMonth(date.year, 2, 7, 0);

	// 得到所求的月份的干支索引
	int l_iMonthGzIndx = (l_index + date.month - 1)%60;
	return g_ganZhi2[l_iMonthGzIndx];
}



//==============================================================================================
// 函 数 名：GetLlGZHour
// 功能描述：获取农历干支时
// 输入参数：l_day_tg   农历日天干
//           l_hour_dz  时辰
// 输出参数：string     农历时干支
// 创建日期：2008-09-19
// 作 者：李学锋
//==============================================================================================
std::string Calendar::GetLlGZHour(const std::string& l_day_tg,const std::string& l_hour_dz)
{
	// 日上起时表
	std::string datasets[12][5] = { {"甲子","丙子","戊子","庚子","壬子"},
									{"乙丑","丁丑","己丑","辛丑","癸丑"},
									{"丙寅","戊寅","庚寅","壬寅","甲寅"},
									{"丁卯","己卯","辛卯","癸卯","乙卯"},
									{"戊辰","庚辰","壬辰","甲辰","丙辰"},
									{"己巳","辛巳","癸巳","乙巳","丁巳"},
									{"庚午","壬午","甲午","丙午","戊午"},
									{"辛未","癸未","乙未","丁未","己未"},
									{"壬申","甲申","丙申","戊申","庚申"},
									{"癸酉","乙酉","丁酉","己酉","辛酉"},
									{"甲戌","丙戌","戊戌","庚戌","壬戌"},
									{"乙亥","丁亥","己亥","辛亥","癸亥"}};

	const std::string hours[12]  = {"子","丑","寅","卯","辰","巳","午", "未","申","酉","戌","亥"};

	int l_i_day = 0;
	int l_i_hour = 0;

	for(int i=0;i<12;++i)
	{
		if(l_hour_dz==hours[i])
		{
			l_i_hour = i;
			break;
		}
	}

	if((l_day_tg == "甲")||(l_day_tg == "己"))
	{
		l_i_day = 0;
	}
	else if((l_day_tg == "乙")||(l_day_tg == "庚"))
	{
		l_i_day = 1;
	}
	else if((l_day_tg == "丙")||(l_day_tg == "辛"))
	{
		l_i_day = 2;
	}
	else if((l_day_tg == "丁")||(l_day_tg == "壬"))
	{
		l_i_day = 3;
	}
	else if((l_day_tg == "戊")||(l_day_tg == "癸"))
	{
		l_i_day = 4;
	}

	return  datasets[l_i_hour][l_i_day];
}


//==============================================================================================
// 函 数 名：GetLlGZHour
// 功能描述：农历转公历日期
// 输入参数：nldate  农历日期
// 输出参数：DateInfo  公历
// 创建日期：2008-10-30
// 作 者：魏光前
//==============================================================================================
DateInfo Calendar::GetGlDate(const DateInfo& nldate)
{
	
	if (nldate.year > 2199 || nldate.year < -849 || nldate.month > 12 || nldate.month < 1 || nldate.day > 30 || nldate.day < 1) return nldate;
	DateInfo gldate;

	if (nldate.year<1900 || nldate.year>2049)
	{
		gldate =  GetGlDateFun(nldate);
	}
	else
	{
		gldate = GetGlDateEx(nldate);
	}
	
	return gldate;
}


//==============================================================================================
// 函 数 名：H2B
// 功能描述：将压缩的阴历字符还原
// 输入参数：nldate.year  年, nldate.month 月, nldate.day日, 是否闺月的第二个月
// 输出参数：string  公历
// 创建日期：2008-10-30
// 作 者：魏光前
//==============================================================================================
std::string Calendar::H2B(const std::string& strHex)
{
    int i;
	int i1;
	std::string H2Bstr;
	std::string tmpV;
	std::string hStr = "0123456789ABCDEF";
	std::string bStr = "0000000100100011010001010110011110001001101010111100110111101111";
	int hval;
    
	tmpV = strHex.substr(0, 3);
    
    //十六进制转二进制
	for (i = 0; i< (int)tmpV.length(); i++)
	{
		i1 = (int)hStr.find(tmpV.substr((int)i, 1));
		H2Bstr += bStr.substr(i1 * 4, 4);
	}
    
	H2Bstr += strHex.substr(3, 2);
    
    //十六进制转十进制
	sscanf(strHex.substr(strHex.length()-2, 2).c_str(), "%x", &hval);
	H2Bstr += "0";

	char szNum[4];
	memset(szNum,0,4);
	sprintf(szNum,"%d", hval);
	H2Bstr += std::string(szNum);
	return H2Bstr;
}

//////////////由八字的使用的中国日历类移植过来/////////////////
//获取农历信息
bool Calendar::GetLunarFromDay(int year, int month, int day,
							   int & lunarYear, int &lunarMonth, int &lunarDay, 
							   bool &isLeapMonth)
{
	int eclipsType, moonPhase;
	double theTime;
	bool ret = false;
	lunarYear = year;
	//改用60甲子表示年份09.11.12 shh
	//lunarYear = GetGanZhiFromYear(year);
	if (year >= -849 && year <= 2100)
	{
		lunarDay = static_cast<int>(GetLunarMoon(year, month, day, 
			eclipsType, moonPhase,theTime));
		lunarMonth = static_cast<int>(GetLunarMonth(year, month, day));
		isLeapMonth = lunarMonth < 0; 
		if (isLeapMonth)
			lunarMonth = -lunarMonth;

		ret = true;

		if (month < lunarMonth)
		{
			lunarYear--;
		}
	}
	return ret;
}

// 取某日期到年初的天数，不考虑 1582 年 10 月的特殊情况
int Calendar::GetDayFromYearBegin(int year, int month, int day)
{
	int ret = 0;
	for (int i = 1; i <= month - 1; ++i)
	{
		ret += GetMonthDays(year, i);
	}
	ret += day;
	return ret;
}

// 取本月天数，不考虑 1582 年 10 月的特殊情况
int Calendar::GetMonthDays(int year, int month)
{
	int monthDay[] = {31, 28, 31, 30, 31, 30,
		31, 31, 30, 31, 30, 31,};
	if (GetIsLeapYear(year))
		monthDay[1] += 1;
	return monthDay[(month - 1) % 12];
}

// 返回某公历是否闰年，自动判断 Julian 还是 Gregorian，支持公元前
bool Calendar::GetIsLeapYear(int year)
{
	bool ret;
	if (GetCalendarType(year, 1, 1) == CT_GREGORIAN)
		ret = ((year % 4 == 0) && (year % 100 != 0)) || year % 400 == 0;
	else if (year >= 0)
		ret = (year % 4 == 0);
	else                // 没有公元0年
		ret = (year - 3) % 4 == 0;
	return ret;
}

// 根据公历日期判断当时历法
int Calendar::GetCalendarType(int year, int month, int day)
{
	int ret = 0;
	if (year < 1582)
		ret = CT_JULIAN;
	else if (year == 1582 && month < 10)
		ret = CT_JULIAN;
	else if (year == 1582 && month == 10 && day <= 4)
		ret = CT_JULIAN;
	else if (year == 1582 && month == 10 && day >= 5 && day <= 14)
		ret = CT_INVALID;
	else
		ret = CT_GREGORIAN;
	return ret;
}

// 获得某公历年内的第 N 个节气距年初的天数，1-24，对应小寒到冬至
double Calendar::GetJieQiDayTimeFromYear(int year, int n)
{
	double juD, tht, yrD, shuoD;
	// 由于进动章动等造成的岁差的影响，
	// 太阳两次通过各个定气点的时间并不是一精确回归年
	// 所以没法以 365.2422 为周期来直接计算各个节气的时刻。下面这个公式属移植而来。
	// 返回的天数是小数，可折算成月日时分。

	// 对没有公元 0 年的调整
	if (year <= 0) year++;

	juD = year * (365.2423112 - 6.4e-14 * (year-100) * (year - 100)
		- 3.047e-8 * (year-100)) + 15.218427 * n + 1721050.71301;
	tht = 3e-4 * year - 0.372781384 - 0.2617913325 * n;
	yrD = (1.945 * sin(tht) - 0.01206 * sin(2*tht)) * (1.048994 - 2.583e-5 * year);
	shuoD = -18e-4 * sin(2.313908653 * year- 0.439822951 - 3.0443 * n);
	return juD + yrD + shuoD - GetEquStandardDays(year, 1, 0) - 1721425; // 定气
	// (juD - GetEquStandardDays(year, 1, 0) - 1721425); 平气

}

// 获得某公历日的等效标准日数
int Calendar::GetEquStandardDays(int year, int month, int day)
{
	int ret = 0;
	int type = GetCalendarType(year, month, day);
	if (type == CT_JULIAN)
	{
		// 为啥减 2？猜测公元 1 年到 1582 年，Julian 历较 Gregorian 历多闰了 12 天，
		// (100, 200, 300, 500, 600, 700, 900, 1000, 1100, 1300, 1400, 1500)
		// 而 Gregory 只删去 10 天，所以留下了 2 天的差值。
		// 这说明，按 Gregorian 历从 1582.10.4 往前倒推得的 Gregorian 历元年元旦
		// 和实际公元元年元旦不是同一天。
		ret = (year - 1) * 365 + ((year - 1) / 4) +
			GetDayFromYearBegin(year, month, day) - 2;
	}
	else if (type == CT_GREGORIAN)
	{
		ret = (year - 1) * 365 + ((year - 1) / 4) - ((year - 1) / 100) +
			((year - 1) / 400) + GetDayFromYearBegin(year, month, day);
	}
	return ret;
}

// 获得某公历年月日的农历日数和该日月相以及日月食类型和时刻
double Calendar::GetLunarMoon(int year, int month, int day, 
							  int &eclipseType, int &moonPhase, double &theTime)
{
	double K, K1;
	double T, Rpi, Zone, F0, Fc, J0, Aa0, Ab0, Ac0, ShuoTime, WangTime;
	double Aa, Ab, Ac, F1, J;
	int Ms, Leap, LunDay, LunDay0, ShuoDay, WangDay;
	double S, R, P, Q;
	double Pi = 3.1415926535;
	double Result;

	T = (year - 1899.5) / 100;
	Ms = static_cast<int>((year - 1900) * 12.3685);
	Rpi = 180 / Pi;
	Zone = 8;
	F0 = GetAng(Ms, T, 0, 0.75933, 2.172e-4, 1.55e-7)
		+ 0.53058868 * Ms - 8.37e-4 * T + Zone / 24 + 0.5;
	Fc = 0.1734 - 3.93e-4 * T;
	J0 = 693595 + 29 * Ms;
	Aa0 = GetAng(Ms, T, 0.08084821133, 359.2242/Rpi, 0.0000333/Rpi, 0.00000347/Rpi);
	Ab0 = GetAng(Ms, T, 7.171366127999999e-2, 306.0253/Rpi, -0.0107306/Rpi, -0.00001236/Rpi);
	Ac0 = GetAng(Ms, T, 0.08519585128, 21.2964/Rpi, 0.0016528/Rpi, 0.00000239/Rpi);

	Leap = 0;
	eclipseType = ET_NONE;
	LunDay = -1;
	ShuoDay = 0;
	ShuoTime = 0;
	WangDay = 0;
	WangTime = 0;

	K1 = -1; K = -1;
	while (K <= 13)
	{
		Aa = Aa0 + 0.507984293 * K;
		Ab = Ab0 + 6.73377553 * K;
		Ac = Ac0 + 6.818486628 * K;
		F1 = F0 + 1.53058868 * K + Fc * sin(Aa) - 0.4068 * sin(Ab)
			+ 0.0021 * sin(2 * Aa) + 0.0161 * sin(2 * Ab) + 0.0104 * sin(2 * Ac)
			- 0.0074 * sin(Aa - Ab) - 0.0051 * sin(Aa + Ab);

		J = J0 + 28 * K + F1;

		LunDay0 = static_cast<int>(GetEquStandardDays(year, month, day) - static_cast<int>(J));
		if (K == static_cast<int>(K) && (LunDay0 >= 0) && (LunDay0 <= 29))
		{
			K1 = K;
			ShuoTime = GetTail(J);
			LunDay = LunDay0 + 1;
		}
		if (K == K1 + 0.5)
		{
			WangTime = GetTail(J);
			WangDay = static_cast<int>(J) - 
				(GetEquStandardDays(year, month, day) - LunDay + 1) + 1;
		}

		if ((LunDay == 1 && K == K1) || (LunDay == WangDay && K == K1 + 0.5))
		{

			if (fabs(sin(Ac)) <= 0.36)
			{
				S = 5.19595 - 0.0048 * cos(Aa) + 0.002 * cos(2 * Aa) - 0.3283 * cos(Ab)
					- 0.006 * cos(Aa + Ab) + 0.0041 * cos(Aa - Ab);
				R = 0.207 * sin(Aa) + 0.0024 * sin(2 * Aa) - 0.039 * sin(Ab)
					+ 0.0115 * sin(2 * Ab) - 0.0073 * sin(Aa + Ab) - 0.0067 * sin(Aa - Ab)
					+ 0.0117 * sin(2 * Ac);
				P = fabs(S * sin(Ac) + R * cos(Ac));
				Q = 0.0059 + 0.0046 * cos(Ac) - 0.0182 * cos(Ab) + 0.0004 * cos(2 * Ab)
					- 0.0005 * cos(Aa + Ab);


				if (P - Q <= 1.5572)
				{
					eclipseType = ET_SOLAR; // 日食
					if (K != static_cast<int>(K))
					{
						if (P + Q >= 1.0129)
							eclipseType = ET_MOONHALF;  //月偏食
						else
							eclipseType = ET_MOONFULL;  //月全食
					}
				}
			}
		}
		K = K + 0.5;
	}

	// 1924.3.5 ~ 4.3 少一天
	if (year == 1924 && ((month == 3 && day >= 5) || (month == 4 && day <= 3)))
	{
		++LunDay;
		if (LunDay > 30)
			LunDay -= 30;
	}
	// 2018.11.7 ~ 12.6 多一天
	if (year == 2018 && ((month == 11 && day >= 7) || (month == 12 && day <= 6)))
	{
		--LunDay;
		if (LunDay < 1)
			LunDay += 30;
	}

	// 2025.4.27 ~ 5.26 少一天
	if (year == 2025 && ((month == 4 && day >= 7) || (month == 5 && day <= 26)))
	{
		++LunDay;
		if (LunDay > 30) 
			LunDay -= 30;
	}
	Result = LunDay;

	if (LunDay == 1) // 朔日
	{
		moonPhase = MP_SHUO;
		theTime = ShuoTime;
	}
	else if (LunDay == WangDay)
	{
		moonPhase = MP_WANG;
		theTime = WangTime;
	}
	else
	{
		moonPhase = MP_NONE;
		theTime = -1;
	}

	return Result;
}

// 获得某公历年月日的农历月数
double Calendar::GetLunarMonth(int year, int month, int day)
{
	double LunDay;
	int aEclipsType;
	int aMoonPhase;
	double aTime;
	int LeapMons, NMonth;
	double Result;

	LunDay = GetLunarMoon(year, month, day, aEclipsType, aMoonPhase, aTime);
	if (aTime != -1.0)
		LunDay = LunDay + aTime;
	LunDay = floor(LunDay - floor(LunDay / 100) * 100);

	LeapMons = GetLeapNum(year);
	NMonth = static_cast<int>((GetEquStandardDays(year, month, day)
		- GetEquStandardDays(-849, 1, 21) - LunDay) / 29.530588 + 0.5) - LeapMons;

	//历史上的修改月建
	if (year <= 240) ++NMonth;
	if (year <= 237)  --NMonth;
	if (year < 24)  ++NMonth;
	if (year < 9)  --NMonth;
	if (year <= -255)  ++NMonth;
	if (year <= -256)  NMonth += 2;
	if (year <= -722)  ++NMonth;

	Result = static_cast<double>(static_cast<int>(GetRemain(NMonth - 3, 12) + 1 + 0.5));

	if ((Result == GetLeapMonth(year - 1)) && (month == 1) && (day < LunDay))
	{
		Result = - Result;    //如果 year - 1年末是闰月且该月接到了 year 年,则 year 年年初也是闰月
	}
	else if (Result == GetLeapMonth(year))
	{
		if ((month == 1) && (GetLeapMonth(year) != 12)) 
		{
			// 比如1984年有闰10月，而1984.1.1的农历月为10，
			// 但这是从1983年阴历接过来的，所以不是1984年的闰10月
			Result = Result + 1;
		}
		else
		{
			Result = - Result;
		}
	}
	else
	{
		if (Result < GetLeapMonth(year) || (month < Result && GetLeapMonth(year) > 0))
			++Result;  //如果 year 年是闰月但当月未过闰月则前面多扣除了本年的闰月，这里应当补偿
		Result = static_cast<double>(static_cast<int>(GetRemain(Result - 1, 12) + 1 + 0.5));
	}

	// 1924.3.5-4.3 少一天
	if ((year == 1924) && ((month == 3) && (day == 5)))
		Result = Result + 1;

	// 2018.11.7-12.6 多一天
	if ((year == 2018) && ((month == 11) && (day == 7)))
		Result = Result - 1;

	// 2025.4.27-5.26 少一天
	if ((year == 2025) && ((month == 4) && (day == 27)))
		Result = Result + 1;

	return Result;
}

// 某角度计算函数，移植自中国日历类
double Calendar::GetAng(double X, double T, double C1, double T0, double T2, double T3)
{
	double Pi = 3.1415926535;
	return GetTail(C1 * X) * 2 * Pi + T0 - T2 * T * T - T3 * T * T * T;
}

// 获得一大于零的数的小数部分
double Calendar::GetTail(double x)
{
	double ret;
	if (x > 0)
		ret = x - static_cast<int>(x);
	else
		ret = x + static_cast<int>(x);
	return ret;
}
// 移植自中国日历类
int Calendar::GetLeapNum(int year)
{
	int ret;
	if (year < 0)
		ret = g_leapNumber2[year + 849];
	else
		ret = g_leapNumber2[year - 1 + 849];
	return ret;
}

// 移植自中国日历类
int Calendar::GetLeapMonth(int year)
{
	char c = g_leapMonth2[year + 849];
	int ret;
	if (c >= '0' && c <= '9')
		ret = c - '0';
	else if (c >= 'a' && c <= 'c')
		ret = 10 + c - 'a';
	else 
		ret = -1;
	return ret;
}

// 小数的求余数
double Calendar::GetRemain(double X, double W)
{
	return GetTail(X / W) * W;
}

//输入农历的年月信息，返回这个月有多少天。
int Calendar::MonthDaysFun(int y, int m, bool bIsRun)
{
	if (bIsRun)
	{
		if (LeapMonth(y) != m)
		{
			// y年m月不是闰月
			return -1;
		}
		else
		{
			return LeapDaysFun(y);
		}
	}

	DateInfo l_GLDate;//虚构公历日期
	DateInfo l_NLDate;//虚构农历日期
	l_GLDate.year = y;
	l_GLDate.month = m;
	l_GLDate.day = 1;
	
	while (true)
	{
		l_NLDate = Lunar(l_GLDate);
		if (l_NLDate.month == m && l_NLDate.day == 1)
		{
			//找到相应农历的月份
			break;
		}
		else
		{
			l_GLDate = AddOneDay(l_GLDate);
		}
	}
	
	//加上30天，如果到了下个月的初一日，那么说明这个农历月为30天，否则说明这个农历月只有29天
	for (int i = 0; i < 30; i++)
	{
		l_GLDate = AddOneDay(l_GLDate);
	}

	l_NLDate = Lunar(l_GLDate);
	if (l_NLDate.day == 1)
	{
		return 30;
	}
	else
	{
		return 29;
	}	
}

//公历日期加一天
DateInfo Calendar::AddOneDay(const DateInfo& l_date)
{
	//加1天
	DateInfo l_GLDate;
	l_GLDate.year = l_date.year;
	l_GLDate.month = l_date.month;
	l_GLDate.day = l_date.day;

	if (l_GLDate.year == 1582 && l_GLDate.month == 10 && l_GLDate.day == 4)
	{
		//公元1582年10月这个月没有5日~14日
		l_GLDate.day = 15;
		return l_GLDate;
	}

	if (l_GLDate.month==1 || l_GLDate.month==3 || l_GLDate.month==5 || l_GLDate.month==7 ||
		l_GLDate.month==8 || l_GLDate.month==10 || l_GLDate.month==12)
	{
		//大月的情况
		if (l_GLDate.day >= 31)
		{
			l_GLDate.month += 1;
			l_GLDate.day = 1;
			if (l_GLDate.month == 13)
			{
				//到下一年了
				l_GLDate.year += 1;
				l_GLDate.month = 1;
			}

		}
		else
		{
			l_GLDate.day += 1;
		}
	}
	else if (l_GLDate.month==4 || l_GLDate.month==6 || l_GLDate.month== 9 || l_GLDate.month== 11)
	{
		//小月的情况
		if (l_GLDate.day >= 30)
		{
			l_GLDate.month += 1;
			l_GLDate.day = 1;
		}
		else
		{
			l_GLDate.day += 1;
		}
	}
	else
	{
		//2月的情况特殊单独处理
		bool leapFlag = IsLeapYear(l_GLDate.year);
		if (leapFlag)
		{
			//闰年2月有29天
			if (l_GLDate.day >= 29)
			{
				l_GLDate.month += 1;
				l_GLDate.day = 1;
			}
			else
			{
				l_GLDate.day += 1;
			}
		}
		else
		{
			//平年2月只有28天
			if (l_GLDate.day >= 28)
			{
				l_GLDate.month += 1;
				l_GLDate.day = 1;
			}
			else
			{
				l_GLDate.day += 1;
			}
		}
	}

	return l_GLDate;
}

//输入农历年，获取农历年中那个闰月的天数（如果存在闰月的话）
int Calendar::LeapDaysFun(int year)
{
	int m = LeapMonth(year);
	if (m)
	{
		DateInfo l_GLDate;//虚构公历日期
		DateInfo l_NLDate;//虚构农历日期
		l_GLDate.year = year;
		l_GLDate.month = m;
		l_GLDate.day = 1;
		int l_monthDay_1 = 0;//平月的天数

		while (true)
		{
			l_NLDate = Lunar(l_GLDate);
			if (l_NLDate.month == m && l_NLDate.day == 1)
			{
				//找到相应农历的月份
				break;
			}
			else
			{
				l_GLDate = AddOneDay(l_GLDate);
			}
		}

		//加上29天，如果到了下个月的初一日，那么说明这个农历月为29天，否则说明这个农历月只有30天
		for (int i = 0; i < 29; i++)
		{
			l_GLDate = AddOneDay(l_GLDate);
		}

		l_NLDate = Lunar(l_GLDate);
		if (l_NLDate.day == 1)
		{
			l_monthDay_1 =  29;
		}
		else
		{
			l_monthDay_1 =  30;
			l_GLDate = AddOneDay(l_GLDate);
		}	

		for (int i = 0; i < 29; i++)
		{
			l_GLDate = AddOneDay(l_GLDate);
		}
		l_NLDate = Lunar(l_GLDate);
		if (l_NLDate.day == 1)
		{
			l_monthDay_1 =  29; 
		}
		else
		{
			l_monthDay_1 =  30;
		}

		return l_monthDay_1;
	}
	else
	{
		return 0;
	}
}

//从农历获取公历的具体实现方法
DateInfo Calendar::GetGlDateFun(const DateInfo& nldate)
{

	DateInfo l_GLDate;//虚构公历日期
	DateInfo l_NLDate;//虚构农历日期
	l_GLDate.year = nldate.year;
	l_GLDate.month = nldate.month;
	l_GLDate.day = 1;
	
	while (true)
	{
		l_NLDate = Lunar(l_GLDate);
		if (l_NLDate.month == nldate.month && l_NLDate.day == 1)
		{
			//找到相应农历的月份
			break;
		}
		else
		{
			l_GLDate = AddOneDay(l_GLDate);
		}
	}

	if (nldate.isRunYue)
	{
		l_GLDate = AddOneDay(l_GLDate);
		while (true)
		{
			l_NLDate = Lunar(l_GLDate);
			if (l_NLDate.month == nldate.month && l_NLDate.day == 1)
			{
				//找到相应农历的月份
				break;
			}
			else
			{
				l_GLDate = AddOneDay(l_GLDate);
			}
		}
	}

	while (true)
	{
		l_NLDate = Lunar(l_GLDate);
		if (l_NLDate.month == nldate.month && l_NLDate.day == nldate.day)
		{
			//找到相应农历的月份
			break;
		}
		else
		{
			l_GLDate = AddOneDay(l_GLDate);
		}
	}

	return l_GLDate;
}

// 获得某公/农历年的天干地支，0-59 对应 甲子到癸亥
int Calendar::GetGanZhiFromYear(int year)
{
	int ret;
	if (year > 0)
		ret = (year - 4) % 60;
	// 需要独立判断公元前的原因是没有公元 0 年
	else
		ret = (year - 3) % 60;

	if (ret < 0) ret += 60;

	return ret;
}

// 根据公历年月日获得某公历年的天干地支，以立春为年分界，0-59 对应 甲子到癸亥
int Calendar::GetGanZhiFromYear(int year, int month, int day, int hour, int& NLYear)
{
	// 如是立春日前，属于前一年
	int dayOfLiChun = static_cast<int>(floor(GetJieQiDayTimeFromYear(year, 3)));
	if (GetDayFromYearBegin(year, month, day) < dayOfLiChun)
		year--;
	
	NLYear = year;
	return GetGanZhiFromYear(year);
}

// 获得某公历月的天干地支，需要日是因为月以节气分界。0-59 对应 甲子到癸亥
int Calendar::GetGanZhiFromMonth(int year, int month, int day, int hour)
{
	int gan, zhi;

	// 需要先根据节气调整月和年数
	AdjustByJieQi(year, month, day);
	int ret = -1;
	ExtractGanZhi(GetGanZhiFromYear(year), gan, zhi);
	// 根据口诀从本年干数计算本年首月的干数
	// 甲己 丙佐首，乙庚 戊为头，丙辛 寻庚起，丁壬 壬位流，戊癸 甲好求
	int firstGan[] = {2, 4, 6, 8, 0};
	ret = firstGan[gan >= 5 ? gan - 5 : gan];
	// 计算本月干数
	ret += (month - 1) % 10;
	if (ret >= 10) ret %= 10;

	// 组合支数，正月为寅
	ret = CombineGanZhi(ret, (month - 1 + 2) % 12);
	return ret;
}

// 获得某公历日的天干地支，0-59 对应 甲子到癸亥
int Calendar::GetGanZhiFromDay(int year, int month, int day, int hour)
{
	int ret = (GetAllDays(year, month, day) + 12) % 60;

	if (ret < 0 ) ret += 60;

	if (hour == 23)
	{
		(ret==59) ? ret=0 :ret++;
	}
	return ret;
}

// 获得某公历时的天干地支，0-59 对应 甲子到癸亥
int Calendar::GetGanZhiFromHour(int year, int month, int day, int hour)
{
	int gan, zhi;
	hour = hour % 24;
	ExtractGanZhi(GetGanZhiFromDay(year, month, day, hour), gan, zhi);

	// Zhi是时辰数(0-11)也就是支数
	if (hour == 23)
	{
		// 次日子时
		//gan = (gan + 1) % 10;
		gan = gan  % 10;
		zhi  = 0;
	}
	else
	{
		zhi = (hour + 1) / 2;
	}

	// Gan 此时是本日干数，根据规则换算成本日首时辰干数
	// 0, 5 - 0; 1, 6 - 2; 2, 7 - 4; 3, 8 - 6; 4, 9 - 8; 
	if (gan >= 5)
		gan -= 5;
	gan *= 2;

	// 计算此时辰干数
	gan = (gan + zhi) % 10; 
	return CombineGanZhi(gan, zhi);
}

// 调整年和月记录，因为年月的天干地支计算是以立春和各个节气为分界的
void Calendar::AdjustByJieQi(int &year, int &month, int &day)
{
	int days = GetDayFromYearBegin(year, month, day);
	// 如本日是立春日前，则是属于前一年
	if (days < static_cast<int>(GetJieQiDayTimeFromYear(year, 3)))
	{
		year--;
		int xiaoHanDay = static_cast<int>(GetJieQiDayTimeFromYear(year, 1));
		// 如果小于小寒则算 11 月
		if (days < xiaoHanDay)
			month = 11;
		// 小寒和立春间算 12 月
		else
			month = 12;
	}
	else
	{
		// 计算本年的节气，看该日落在哪俩节气内
		// i是以节气为分界的月份数
		for (int i = 1; i <= 12; ++i)
		{
			int jieqiDay = static_cast<int>(GetJieQiDayTimeFromYear(year, 2 * i + 1));
			// 如果 I 月首节气的距年头的日数小于此日
			if (days >= jieqiDay)
				month = i;
			else
				break;
		}
	}
}

// 将干支拆分成天干地支，0-59 转换成 0-9 0-11
bool Calendar::ExtractGanZhi(int ganzhi, int &gan, int &zhi)
{
	if (ganzhi < 0 || ganzhi > 59) return false;
	gan = ganzhi % 10;
	zhi = ganzhi % 12;
	return true;
}

// 将天干地支组合成干支，0-9 0-11 转换成 0-59
int Calendar::CombineGanZhi(int gan, int zhi)
{
	int ret = -1;
	for (int i = 0; i < 6; ++i)
	{
		int ganzhi = i * 10 + gan;
		if (ganzhi % 12 == zhi)
		{
			ret = ganzhi;
			break;
		}
	}
	return ret;
}

// 获得距公元元年 1 月 0 日的绝对天数
int Calendar::GetAllDays(int year, int month, int day)
{
	return GetBasicDays(year, month, day) + GetLeapDays(year, month, day);
}

// 获取到公元原点的闰年总天数
int Calendar::GetLeapDays(int year, int month, int day)
{
	int ret;
	// 公元后
	if (year >= 0)
	{
		int type = GetCalendarType(year, month, day);
		if (type == CT_JULIAN || type == CT_INVALID)
			ret = 0;
		// 1582.10.5/15 前的 Julian 历只有四年一闰，历法此日后调整为 Gregorian 历
		else
		{
			// 被 Gregory 删去的 10 天
			ret = 10;
			// 修正算法简化版，从 1701 年的 11 起
			if (year > 1700)
			{
				// 每一世纪累加一
				ret += 1 + (year - 1701) / 100;
				// 但 400 整除的世纪不加
				ret -= (year - 1601) / 400;
			}
		}
		// 4 年一闰数
		ret = (year - 1) / 4 - ret;
	}
	// 公元前
	else
	{
		ret = -((-year + 3) / 4);
	}
	return ret;
}

// 获取到公元原点的基本天数
int Calendar::GetBasicDays(int year, int month, int day)
{
	int ret = 0;
	if (year > 0) 
		ret = (year - 1) * 365;
	else 
		ret = year * 365;

	for (int i = 1; i <= month - 1; ++i)
		ret += GetMonthDays(year, i);
	ret += day;
	//
	////转折点，闰月存在
	//if(GetIsLeapYear(year) && (month == 12))
	//	ret -= 1;
	return ret;
}


// 获取天干的序号
int Calendar::GetTianGanIndex(const std::string& sTianGan)
{
	std::string l_s_tiangan[] = {"甲","乙","丙","丁","戊","己","庚","辛","壬","癸"};/*天干名称*/
	for(int i =0;i<10;++i)
	{
		if(sTianGan == l_s_tiangan[i] )
		{
			return i;
		}
	}
	return -1;
}



// 获取地址的序号
int Calendar::GetDiZhiIndex(const std::string& sDiZhi)
{
	std::string l_s_dizhi[] =  {"子","丑","寅","卯","辰","巳","午", "未","申","酉","戌","亥"};
	for(int i =0;i<12;++i)
	{
		if(sDiZhi == l_s_dizhi[i] )
		{
			return i;
		}
	}
	return -1;
}

// 不考虑立春节气的影响，取一年的年干支(用于紫微排盘)
//LunarInfo Calendar::GetYearGanZhi_NoCase_LiChun(int iNlYear)
//{
//	// 虚构这个年中的某一天
//	DateInfo l_tempDate;
//	l_tempDate.year = iNlYear;
//	l_tempDate.month = 5;
//	l_tempDate.day = 1;
//	l_tempDate.hour = 10;
//	l_tempDate.isRunYue = false;
//	LunarInfo l_tempNlinfo = GetLunarInfo(l_tempDate);
//	return l_tempNlinfo;
//}

// 不考虑立春节气的影响，取年干的索引(用户紫微快速排盘)
int Calendar::GetYearGanIndex_NoCase_LiChun(int iNlYear)
{
	if (iNlYear < 4)
	{
		return 0;
	}
	//const char *cTianGan[]  = {"甲","乙","丙","丁","戊","己","庚","辛","壬","癸"}; /*天干名称*/

	int iTianGan = ((iNlYear - 4) % 60) % 10;
	if ( iTianGan < 0 || iTianGan > 9 )
	{
		return 0;
	}
	else
	{
		return iTianGan;
	}
}

//// 公历日期加上iOffset天后，是公历的几月几日(beginDate 为公历日期)
//DateInfo Calendar::AddDaysOffset(const DateInfo& beginDate, int iOffset)
//{
//	if (iOffset <= 0 || beginDate.year < 1600)
//	{
//		// 天数为负数，起始年份小于1600年的，暂且不算，为了避开1582年的的那缺失的10天
//		return beginDate;
//	}
//
//	DateInfo resDate;
//
//	//if (beginDate.year == 1582 && beginDate.month == 10 && (beginDate.day>=5 && beginDate.day<=14))
//	//{
//	//	// 公元1582年10月这个月没有5日~14日
//	//	return beginDate;
//	//}
//
//
//}

// 由农历的时间求出公历的时间（时间范围：公历1900年1月31日~公历2050年1月22日）
// （时间范围：农历1900年1月1日~农历2049年12月29）
DateInfo Calendar::GetGlDateEx(const DateInfo& nlDate)
{
	DateInfo glDate;
	if (nlDate.year<1900 || nlDate.year>2049)
	{
		glDate.year = -1;
		return glDate;
	}

	// 这一年是那个月闰，无闰月的话为0
	int l_iLeepMonth = lunarInfo[nlDate.year-1900]&0xf; 

	// 判断输入的农历日期的合法性--针对闰月设置是否正确来判断
	if (nlDate.isRunYue && l_iLeepMonth!=nlDate.month)
	{
		glDate.year = -2;
		return glDate;
	}

	// 计算输入的农历日期到农历1900年1月1日间隔了几天
	int iOffSet = 0; 

	// 1、求nlDate.year的1月1日到起始标准间的天数

	if (nlDate.year == 1900)
	{
		iOffSet = 0;
	}
	else
	{
		iOffSet = NlYearDaysList[nlDate.year-1900-1];
	}

	// 2、求nlDate.month月1日到当年1月1日间隔的天数
	int iRet = 0;


	if (l_iLeepMonth == 0)
	{
		int j = 1;
		for (int i = 0x8000; i>0x8 && j<nlDate.month; i>>=1)
		{
			iRet += (lunarInfo[nlDate.year-1900] & i)? 1: 0;
			j++;
		}

		iRet += 29*(nlDate.month-1);
	}
	else
	{
		if (nlDate.isRunYue)
		{
			// 所求的这个月正好是闰月
			int j = 1;
			for (int i = 0x8000; i>0x8 && j<=nlDate.month; i>>=1)
			{
				iRet += (lunarInfo[nlDate.year-1900] & i)? 1: 0;
				j++;
			}

			iRet += 29*(nlDate.month);
		}
		else
		{
			int j = 1;
			for (int i = 0x8000; i>0x8 && j<nlDate.month; i>>=1)
			{
				iRet += (lunarInfo[nlDate.year-1900] & i)? 1: 0;
				j++;
			}

			iRet += 29*(nlDate.month-1);

			if (nlDate.month>l_iLeepMonth)
			{
				// 所求月在闰月之后，则再加上闰月那天的天数
				iRet += ((lunarInfo[nlDate.year-1900] & 0x10000)? 30: 29);
			}
		}
	}

	iOffSet += iRet;
	iOffSet += (nlDate.day - 1);

	// 时间回退到1900年1月1日，从这天开始计算
	iOffSet += 31;

	int l_iMonthIdx = 0;
	int l_iMonthDays = 0;
	int l_iYearIdx = 0;
	glDate.year = 1900;
	glDate.month = 1;
	glDate.day = 1;

	while (true)
	{
		if (iOffSet - GlYearDaysList[l_iYearIdx] > 0)
		{
			l_iYearIdx++;
			continue;
		}
		else
		{
			if (l_iYearIdx > 0)
			{
				iOffSet -= GlYearDaysList[l_iYearIdx-1];
			}
		}

		glDate.year = 1900 + l_iYearIdx;
		break;
	}

	for (l_iMonthIdx = 0; l_iMonthIdx < 12; l_iMonthIdx++)
	{
		if (l_iMonthIdx == 1 && ((glDate.year%4==0&&glDate.year%100!=0)||glDate.year%400==0))
		{
			l_iMonthDays = 29;
		}
		else
		{
			l_iMonthDays = solarMonth[l_iMonthIdx];
		}

		iOffSet -= l_iMonthDays;

		if (iOffSet <= 0)
		{
			glDate.month = l_iMonthIdx+1;
			glDate.day = iOffSet + l_iMonthDays;
			break;
		}
	}

	return glDate;
}

// 日期在公历1900年1月31日~2049年12月31日的  公历转农历方法
DateInfo Calendar::LunarEx(const DateInfo& glDate)
{
	DateInfo retdate;

	long offset;
	int i, leap=0, temp=0;

	// 定位到1900年1月31日（农历1900年1月1日）
	offset=LDaysFrom1900(glDate)-30;

	for(i=1900; i<2050 && offset>0; i++)
	{
		temp = LYearDays(i);
		offset -= temp;
	}

	if(offset<0)
	{
		offset += temp;
		i--;
	}

	retdate.year = i;

	leap = LeapMonth(i);
	bool isLeap = false;

	for(i=1; i<13 && offset>0; i++)
	{
		if(leap>0 && i==(leap+1) && isLeap==false)
		{
			--i;
			isLeap = true;
			if(LeapMonth(retdate.year))
			{
				temp =  (lunarInfo[retdate.year-1900] & 0x10000)? 30: 29;
			}
			else
			{
				temp =  0;
			}
		}
		else
		{
			temp = (lunarInfo[retdate.year-1900] & (0x10000>>i))? 30: 29;
		}
		if(isLeap==true && i==(leap+1)) 
		{
			isLeap = false;
		}
		offset -= temp;
	}
	//if(offset==0 && leap>0 && i==leap+1)
	//{
	//	if(isLeap)
	//	{ 
	//		isLeap = false;
	//	}
	//	else
	//	{
	//		isLeap = true;
	//	//	--i;
	//	}
	//   }
	if(offset<=0)
	{
		offset += temp;
		--i;
	}
	retdate.month = i;
	retdate.day = offset ;
	retdate.isRunYue=isLeap;

	if (retdate.month == 0)
	{
		retdate.year = retdate.year - 1;
		retdate.month = 12;
		offset = (lunarInfo[retdate.year-1900] & (0x10000>>12))? 30: 29;
		retdate.day = offset;
	}

	return retdate;
}
